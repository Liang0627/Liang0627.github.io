[{"id":"74d3955e22ee642a1387ab630b63e268","title":"About the first of c++ programming","content":"关于程序设计第一次T3模测总结一下这一次的T3模测，也是神经大条的睡过头了，多睡了半个小时，上考场刚睡醒，脑子还是懵的\n导致四道题目一题没有写出来，有点羞愧，下面简单的说一下各道题目吧\n1.\n题目描述给定一个矩阵A，其大小为n×m，其中第行列位置的数记为Aj一个位置被称为高点，当且仅当其上下左右四个方向，若对应位置数值存在时，均小于当前位置的值例如，在一个4×3的矩阵内：·若A2.2为高点，则A2.2&gt;A1.2,A2.2&gt;A2.1,A2.2&gt;A3.2,A2.2&gt;A2.3·若A12为高点，则A12&gt;A11,A12&gt;A1.3,A1.2&gt;A2.2·若A4.3为高点，则A4.3&gt;A3.3，A4.3&gt;A42输入格式第一行两个数n.m用空格隔开，分别表示矩阵的行数与列数。接下来n行，每行m个整数，用空格隔开，表示矩阵输出格式输出一个数表示高点的个数数据规模·对于30%的数据，n=1或m=1·对于30%的数据，矩阵中的值只有0或1·对于100%的数据，1&lt;n，m&lt;500，矩阵的值不大于10\n这道题目还是比较简单的，直接暴力就可以做出来，判断四条边界情况和中间方形矩阵情况就可以\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;int a[600][600]=&#123;0&#125;;int main()&#123;   int n=0,m=0; //n是行 m是列   cin&gt;&gt;n&gt;&gt;m;   for(int i=1;i&lt;=n;i++)   &#123;       for(int j=1;j&lt;=m;j++)       &#123;           cin&gt;&gt;a[i][j];       &#125;   &#125;   if(n==1&amp;&amp;m==1) cout&lt;&lt;&quot;0&quot;;   int ans=0;   for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=m;j++)        &#123;            if(i==1)            &#123;                if(j==1)                &#123;                    if(a[i][j+1]-a[i][j]&lt;0&amp;&amp;a[i+1][j]-a[i][j]&lt;0) ans++; continue;//a[i][j+1]-a[i][j]&lt;0 右   a[i+1][j]-a[i][j]&lt;0  下                &#125;                else if(j==m)                &#123;                    if(a[i][j-1]-a[i][j]&lt;0&amp;&amp;a[i+1][j]-a[i][j]&lt;0) ans++; continue;//a[i][j-1]-a[i][j]&lt;0 左   a[i-1][j]-a[i][j]&lt;0  上                &#125;                else                &#123;                    if(a[i][j+1]-a[i][j]&lt;0&amp;&amp;a[i+1][j]-a[i][j]&lt;0&amp;&amp;a[i][j-1]-a[i][j]&lt;0) ans++; continue;                &#125;            &#125;            if(i==n)            &#123;                if(j==1)                &#123;                    if(a[i][j+1]-a[i][j]&lt;0&amp;&amp;a[i-1][j]-a[i][j]&lt;0) ans++; continue;                &#125;                else if(j==m)                &#123;                    if(a[i][j-1]-a[i][j]&lt;0&amp;&amp;a[i-1][j]-a[i][j]&lt;0) ans++; continue;                &#125;                else                &#123;                    if(a[i][j-1]-a[i][j]&lt;0&amp;&amp;a[i-1][j]-a[i][j]&lt;0&amp;&amp;a[i][j+1]-a[i][j]&lt;0) ans++; continue;                &#125;            &#125;            if(j==1)            &#123;                if(a[i-1][j]-a[i][j]&lt;0&amp;&amp;a[i][j+1]-a[i][j]&lt;0&amp;&amp;a[i+1][j]-a[i][j]&lt;0) ans++; continue;            &#125;            if(j==m)            &#123;                if(a[i][j-1]-a[i][j]&lt;0&amp;&amp;a[i-1][j]-a[i][j]&lt;0&amp;&amp;a[i+1][j]-a[i][j]&lt;0) ans++; continue;            &#125;            if(a[i][j-1]-a[i][j]&lt;0&amp;&amp;a[i-1][j]-a[i][j]&lt;0&amp;&amp;a[i][j+1]-a[i][j]&lt;0&amp;&amp;a[i+1][j]-a[i][j]&lt;0) ans++;        &#125;    &#125;    cout&lt;&lt;ans;&#125;\n\n\n\n2.\n每次打完比赛时候，shy会组织大家玩游戏来放松心情今天要玩的游戏是报数。n个人围成一个圈，顺时针编号为1，2，.，。开始时1号人报1，随后2号人报2，当n号人报n后，下一次报数由1号人报n+1，以此类推特殊的，如果第号人需要报出的数包含7或者是7的倍数，他就应该用拍手取代报数题目描述shy知道有多少个人参与，并且可以决定报数报到m时停止。现在，他想知道每个人拍了多少次手。输入格式第一行输入两个整数n，m，表示有n个人围成一圈，报数报到m停止。输出格式输出一行n个整数，以空格隔开，第个数表示第个人拍手的次数数据规模与子任务对于100%的数据，1&lt;n&lt;50，1&lt;m&lt;6666\n这道题目也是很简单的题，判断一下数的每一位有没有7或者模是否等于0就可以，但是要注意下标的问题，假如刚好n=7，那么存储次数的则会是0下标就不对了\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;int a[10000];int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=m;i++) &#123;        if (i % 7 == 0) &#123;            if (i % n == 0) &#123;                a[n]++;            &#125; else &#123;                a[i % n]++;            &#125;        &#125;        else        &#123;            int j = i;            while (j != 0)            &#123;                if (j % 10 == 7)                &#123;                    if (i % n == 0)                    &#123;                        a[n]++;                        break;                    &#125;                    else                    &#123;                        a[i % n]++;                        break;                    &#125;                &#125;                j /= 10;            &#125;        &#125;    &#125;        for(int c=1;c&lt;=n;c++)        &#123;            cout&lt;&lt;a[c]&lt;&lt;&quot; &quot;;        &#125;&#125;\n\n\n\n3.\n题目背景有一个n×n×n大小的立方体蛋糕被实验室里机饿的同学一人一刀切成了若干个长方体。shy想要吃最大的那块，于是他想知道每切一刀之后最大的蛋糕块体积是多少题目描述假设切蛋糕的刀面，必定与三个坐标轴x,y,z之一垂直现在知道了每一刀切下去的方向和刀面距离原点的距离，你要做的就是帮shy算出每一刀切完之后，最大蛋糕块的体积提示：题日中的蛋糕可以认为是刚体，切割蛋糕不会造成任何损失输入格式第一行输入两个整数n，m。表示蛋糕边长为n，切m刀第二行输入m个字符，以空格隔开。字符只包含x，y，三个字符，第个字符表示第刀的刀面与哪个轴垂直。第三行输入m个整数，以空格隔开。第个整数表示第刀的刀面到原点的距离。输出格式输出m个整数，每个数占一行，第个数表示切了第刀之后最大蛋糕块体积\n这个题就开始有点难了，这里我开始想的和题意不一样，我以为分出一块之后，那一块是不要的，但是其实分出来的蛋糕还要和后面的进行比较，这里是这么做的，记录一下每个轴切的大小，遍历轴开始排序，排序完大，头尾取最大，然后让后一项减前面的，两个比较取最大，后面就简单了\n12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,m;    cin&gt;&gt;n&gt;&gt;m; //n为蛋糕边长 m为切多少刀    vector&lt;long long&gt; dir;    vector&lt;long long&gt; d[3];    for(int i=1;i&lt;=m;i++)    &#123;       string s;       cin&gt;&gt;s;       dir.emplace_back(s[0]-&#x27;x&#x27;);    &#125;    for(int i=0;i&lt;m;i++) &#123;        long long pos;        cin &gt;&gt; pos;        d[dir[i]].emplace_back(pos);        long long res = 1;        for (auto &amp;arr:d) &#123;            sort(arr.begin(), arr.end());            long long mx = 0;            if (!arr.empty()) &#123;                mx = max(arr.front(), n - arr.back());            &#125;                for (int j = 1; j &lt; arr.size(); j++) &#123;                    mx = max(arr[j] - arr[j - 1], mx);                &#125;                    if (mx == 0) &#123;                        res *= n;                    &#125; else &#123;                        res *= mx;                    &#125;                &#125;        cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n\n4.\n题目描述shy喜欢仰望星空，并热衷于收集天上的星星。他把星空抽象成一个二维的平面，并制作了一个大小为n×m的地图，经过一段时间的积累，他已经标记了个有星星的位置为了收集星星，他制造了一个机器人，来收集这些星星。开始时，机器人位于地图的左上角，坐标为（1，1）的位置。现在他向机器人发出了t条指令，每条指令的格式为一Dirstep，Dir为一个字符，表示方向，step是一个整数，表示前进的步数Dir只包含四个字符：W.A.S.D·表示向上行动·A表示向左行动·S表示向下行动·D表示向石行动他想知道，机器人执行完所有指令后，能摘到多少星星输入格式第一行，两个数，m用空格隔开，分别表示地图的长与宽。第二行，一个整数表示星星的总个数接下来k行，每行两个数，表示坐标（x,y）处有星星。（1&lt;x&lt;n,1&lt;y&lt;m）接下来1行，一个数表示有峰指令。接下来t行，每行一个字符加一个整数。字符表示方向，整数表示步数注：1.一个相同位置（x,y）可能出现不止一次，但是，此位置只有一个星星2.星星在摘完一次后，就会消失。也就是说，同一个位置经过多次，只有第一次能收集到星星3.保证机器人不会走出地图范围输出格式输出一行，一个数表示收集到的星星个数\n这个题就稍微有点麻烦了，首先搞清楚upper_bound()—是大于这个数的第一个数 lower是大于等于\n这个要用set来进行优化，列出四种情况\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; SX[100010]; //x下所有星星的y坐标set&lt;int&gt; SY[100010]; //y下所有星星的x坐标set&lt;pair&lt;int,int&gt;&gt; ct; //记录有多少个星星int main()&#123;    int n,m,k,t;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=1;i&lt;=k;i++)    &#123;        int x,y;        cin&gt;&gt;x&gt;&gt;y;        ct.emplace(x,y);        SX[x].emplace(y);        SY[y].emplace(x);    &#125;    k=(int)ct.size(); //更新k，以免重复计算    string s;    cin&gt;&gt;t;    int PX=1,PY=1;    for(int i=1,v;i&lt;=t;i++)    &#123;        cin&gt;&gt;s&gt;&gt;v;        vector&lt;int&gt; WillDelete;        set&lt;int&gt;::iterator it;        if(s[0]==&#x27;A&#x27;)        &#123;            it=SX[PX].upper_bound(PY);            for(;it!=SX[PX].begin();)            &#123;                --it;                if(*it&lt;PY-v) break;                ct.erase(&#123;PX,*it&#125;);                WillDelete.emplace_back(*it);            &#125;            for(auto &amp;x:WillDelete) SX[PX].erase(x);            PY-=v;        &#125;        if(s[0]==&#x27;W&#x27;)        &#123;            it=SY[PY].upper_bound(PX);            for(;it!=SY[PY].begin();)            &#123;                --it;                if(*it&lt;PX-v) break;                ct.erase(&#123;*it,PY&#125;);                WillDelete.emplace_back(*it);            &#125;            for(auto x:WillDelete) SY[PY].erase(x);            PX-=v;        &#125;        if(s[0]==&#x27;D&#x27;)        &#123;            it=SX[PX].lower_bound(PY);            for(;it!=SX[PX].end();++it)            &#123;                if(*it&gt;PY+v) break;                ct.erase(&#123;PX,*it&#125;);                WillDelete.emplace_back(*it);            &#125;            for(auto &amp;x:WillDelete) SX[PX].erase(x);            PY+=v;        &#125;        if(s[0]==&#x27;S&#x27;)        &#123;            it=SY[PY].lower_bound(PX);            for(;it!=SY[PY].end();++it)            &#123;                if(*it&gt;PX+v) break;                ct.erase(&#123;*it,PY&#125;);                WillDelete.emplace_back(*it);            &#125;            for(auto x:WillDelete) SY[PY].erase(x);            PX+=v;        &#125;    &#125;    cout&lt;&lt;k-ct.size();    return 0;&#125;\n\n","slug":"test1","date":"2022-03-12T14:46:11.000Z","categories_index":"","tags_index":"c++","author_index":"huihui"},{"id":"5286650468b52ad05200c33f50f2a04a","title":"First homework of cloud computing","content":"第一次云计算作业\n云使能技术主要包括哪些技术组件？简要说明其关键特性\n12345678数据中心技术：一种特殊的IT基础设施，用于集中放置IT资源；虚拟化技术：是将物理IT资源转换为虚拟IT资源的过程，虚拟服务器使用自己的客户操作系统，独立于创建虚拟服务器的操作系统，在虚拟服务器上运行的客户操作系统和应用软件，都不会感知到虚拟化的过程；Web技术：WWW是由通过Internet访问的互联IT资源构成的系统，其两个基本组件是Web浏览器客户端和Web服务器；多租户技术：使用隔离，数据安全，可恢复性，应用升级，可扩展性，使用计费，数据层隔离；服务技术：基于Web的服务(如Web服务和REST服务)依靠非专有通信和技术接口定义来建立基于Web技术的标准通信框架，服务代理提供事件驱动运行时处理，适用于云中大量的功能。许多代理都自动部署在操作系统和基于云的产品中，服务中间件(如ESB和业务流程平台)可以在云上部署。\n列举至少3中虚拟化软件，并概括其特点\n12345VMware ESXi重点于服务器虚拟化，技术较成熟，功能也多，支持虚机系统多；Xenserver重点在于桌面虚拟化，性价比高，网络性能好，适用于快速与大规模部署，支持系统也不少，但做桌面能发布出来的只有MS系统；Hyper-V起步的最晚，目前貌似只支持MS自家的系统，属于服务器级的，Server08版自带功能。\n\n","slug":"homework","date":"2022-03-09T12:41:31.000Z","categories_index":"","tags_index":"cloud computing","author_index":"huihui"},{"id":"9086f67909bbd861c194370f944fa4e4","title":"about install hexo","content":" 从今天下午开始就配置hexo的环境，主要还是难在命令，在配置的过程中，踩过的一些坑\n比如：4000端口被占用 必须server s -p port 进行端口转换\n还有配置环境一定要在myblog里面进行配置(cd myblog)\n常用的hexo命令：\n创建个新文章1$ hexo new &quot;my new post&quot;\n\n跑一下服务器1$ hexo server\n\n","slug":"hexo","date":"2022-03-07T09:23:43.000Z","categories_index":"","tags_index":"hexo","author_index":"huihui"}]